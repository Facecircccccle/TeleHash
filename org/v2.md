telehash v2 (draft)
===================

# Introduction

(note: this is the second major version of the telehash protocol, the first one is deprecated and was a minimal experimental spec to create a distributed hash table, it is very much a work in progress yet and unstable!)

Telehash is a new encrypted mesh protocol enabling applications to find, identify, and communicate directly with each other.  It is built on public-key security (PKI) and fundamentally creates peer-to-peer (P2P) connections using a distributed hash-table (DHT) to form the mesh.  As a protocol it doesn't provide direct end-user functionality (you won't find "client apps" here) but is primarily a tool for developers (specs and libraries/SDKs) to use in creating modern apps that require rich experiences and private interconnectivity at scale.

The principle idea that drove the creation and development of telehash is the belief that any app should be able to easily and securely talk to any other app (either two instances of the same app or between completely different apps) directly and in any environment (servers, mobile, sensors, etc).  By enabling this freedom for developers as a foundation for their apps it then enables the same freedom for the people using them, that they can connect, share, and communicate privately more easily.

The challenges and complexity right now in connecting apps via existing technologies such as APIs, OAuth, and REST is only increasing, often forcing fundamentally insecure centralized and closed/gated communication platforms.  By adopting telehash in any app it immediately has a powerful set of open tools for not only its own needs, but can then also enable connectivity to and from apps created by others easily. These tools include the ability to have friends, sharing, feeds, tagging, search, notifications, discovery, and other social patterns.

The foundation of the protocol builds on JSON as the core extensible data format with a requirement to keep it simple and lightweight enough to support apps running on networked devices and sensors. The design goals include not forcing any particular architecture design such as client-server, centralized/federated/distributed, polling/push, REST, streaming, publish-subscribe, or message passing... any can be used as telehash simply facilitates creating the bi-directional connectivity between any two or more apps.

There's some high level concepts that are important to understand when talking about anything using telehash, and the first one is that of a "network", the term describing how all telehash apps are organized.  A network is identified by it's hostname (such as "telehash.org" is one network) and is the primary form of trust and authority between apps.  Each network has one or more "operators" which facilitate access to other apps in the network via the DHT and can provide other administrative services depending on the app.

Every instance of an app has a unique public id on each network it's connected to that is called it's "hashname" and is the primary means of finding and communicating with other instances in the network. Any app may have one or more networks that it's connected to, including private ones for app-specific services and public ones that are providing functionality to many apps.

# Getting Started

In order to use telehash in an app it will need to include a switch (below, the software layer that speaks the protocol), generate an RSA key-pair (every unique instance of an app has it's own and it's used to create it's hashname(s)), and connect to a network (can start with "telehash.org").  Once it's connected it can find and access other hashnames as well as provide services to back out to anyone on that network.  

Most apps will need their own network for access to their back-end, user management, profiles, notifications, etc facilities. To create a new network you simply need to add a DNS SRV record to the hostname for your network that identifies one or more hashnames of operators that manage it.  (todo show example operators, software and patterns)

## Telehash Switches

The software implementations of the telehash protocol are called a "switch" and it's highly suggested to use an existing switch library or service for your platform or language versus trying to create one from scratch in order to ensure that the security and identity aspects are verified properly. If there isn't one yet then we'd love your help, pull requests to list them here are welcome!

* Node.js - [node-telehash](http://github.com/quartzjer/node-telehash)

---

# Protocol Details

## Vocab

* DHT - Distributed Hash Table
* NAT - A device/router that acts as a bridge to internal IPPs (Network Address Translation)
* Hashname - The SHA1(public key + network) of an RSA keypair that is part of a network, the unique ID of an individual application/instance using telehash
* Packet - A UDP packet less than 1400 bytes sent between any hashnames
* Switch - The name of the software layer or service parsing packets for one or more hashnames
* Network - A regular hostname representing a collection of hashnames that have some trust or shared resources
* Operator - A special hashname that acts as a coordinator to introduce/describe a network to any other hashname
* Link - A portable permission from one hashname to another of a shared resource or identity, a signed voucher
* Line - When any two hashnames connect and exchange their identity to form a temporary encrypted session

### Networks

A network is simply a collection of RSA public keys that have some trust each other (typically a single application domain or service) and is identified simply by a valid hostname.  Every public key within a network is identified by it's hashname, which is the SHA1 of it's public key + network name (simple string append of SHA1(pubkey+network)).

Any network may have special "operators" who help seed new hashnames into it and can also provide app-specific administrative services. The list of operators is either dynamically resolved via DNS SRV records or simply bundled privately within an app (seed list).  To resolve a list of operators the names returned from a SRV query on _telehash._udp.network must provide one or more hostnames that each individually resolve with an A record their own IP address and a TXT record of their public key, so that the switch has the three required parts to connect to an operator, it's public key, IP, and port.

## Parsing

Every packet must begin with two bytes that are a short unsigned integer representing the length of bytes that follow it.  That length of bytes are UTF8 encoded JSON and can be parsed by any JSON parser.  The JSON is required so the length must be greater than two (the minimum JSON "{}" string) and less than the length of the raw UDP message minus two (the bytes for the short unsigned integer). Any remaining bytes on the packet are considered raw binary and referenced as the 'BODY' when used.

    <length><JSON>[BODY]

Example decoding logic in node (simplified):
``` js
dgram.createSocket("udp4", function(msg){
	var length = msg.readUInt16BE(0);
    var js = JSON.parse(msg.toString("utf8", 2, length + 2));
	var body = msg.slice(length + 2);
});
```

It is a very common pattern for multiple packets to be included in one UDP message, where the BODY is actually another packet, so switch implementations must be prepared to decode a packet generically on demand from a set of raw bytes.

## JSON

The JSON often acts as the header for a packet that has a binary payload, or can be the entire thing.  The fields used vary depending on the context and are specified below, but all initial packets contain a "type" field with a string value.


## BODY

The optional BODY is always a raw binary of the remainder bytes between the packet's total length and that of the JSON as indicated by LENGTH above. Often a BODY is another full raw packet and will be decoded identically to being read from the network, this pattern of one packet enclosing/attaching another is how the RSA signatures and encryption are implemented.

The BODY is also used as the raw (optionally binary) content transport for streams and for any app-specific usage.

## Packet Processing

When a packet is being processed from a UDP message initially, it's JSON must contain a "type" field with a string value of "open" or "line", each of which determine how to process the BODY of the packet:

* [open](#open) - this is a request to establish a new encrypted session (a `line`) and contains the data to do so
* [line](#line) - this is an encrypted packet for an already established session

Once a line is established, all packets sent thereafter within a line will contain a [stream](#stream) as the content-transport method between any two hashnames.

<a name="open" />
### `open` - Establishing a Line

When a packet is of "type":"open" it must also contain an "open":"encrypted" and "sig":"signature" along with it.  These are used to establish a temporary session between any two hashnames, called a "line".

The string value of the "open" key is created by generating a random secret, and encrypting it *to* the recipients public key, using RSA PKCS1 padding and base64 encoding.  The recipient can then decrypt this using their private key and get the contained secret.  This secret is used to decipher the included binary body using AES-128-CBC, and once unencrypted it is decoded and processed as another packet.

The string value of the "sig" key is an RSA HMAC-MD5 signature encoded as base64, and that is created by the sender signing the binary/encrypted body. To verify, first decrypt the body using the secret (above), and after decoding the enclosed packet, it's body will be the sender's public key. Using that the signature value can be validated.

Once the decoded packet's signature is verified, it MUST also contain the following four fields in the JSON:

* `network` - which network this line is being created for
* `line` - the unique id the recipient must use for sending any line packets, a 40 length hex value (SHA1)
* `at` - an integer timestamp of when it was sent, used to another open request is newer

<a name="line" />
#### `line` - Packet Encryption

A packet with a "type":"line" is only sent/valid after an open has been exchanged, and is required to have a "line":"..." with the value being the same as the recipient sent in it's open.  This ensures that no line packets can be received without being invited in an open.

The BODY is a binary encoded encrypted packet using AES-128-CBC and the secret from the sender's original open packet.  Once decrypted, the recipient then processes it as a normal packet (LENGTH/JSON/BODY) from the sending hashname.

<a name="stream" />
### `stream` - Content Transport

All data sent between any two hashnames (inside a line packet) must contain a "stream":"hash" with a unique 40 length hex value (SHA1) determined by the sender for each different exchange or channel.  A stream always begins with a "type":"..." to tell the recipient what kind of stream it is, and may not have any response, or may be long-lived with many packets exchanged using the same "stream" identifier. At any point a stream can be closed by sending an `end` with the value of true, and if it was an error a string message can be included as the value of the `err` key.

The `type` value of a new stream can be of the following (or use the "_custom" pattern for app-specific uses):

* [seek](#seek) - return any pointers to other closer hashnames for the given `hash` (DHT), answer contains `see`
* [sock](#sock) - raw socket proxy
* [peer](#peer) - ask the recipient to make an introduction to one of it's peers
* [connect](#connect) - ask the recipient to open a connection to a new hashname
* [link](#links) - request for the value of the given link, answer contains `sig` and BODY is the link value
* [create](#create) - new link request, must contain details as required for the type of link, answer will be the same as a link q if successful

All UDP packets are by their very nature lossy, so "seq":integer adds a lightweight mechanism to preserve order, add buffering/backpressure, and retransmit dropped packets.  All seq values start at 0 and increment per packet sent. A buffer of these packets must be kept keyed by the seq value until the receiving hashname has responded confirming them in a `ack` and not in the `miss`. The `ack` is the highest known `seq` value received. The `miss` is an array of integers and must be sent along with any `ack` if in the process of receiving packets there were any missing sequences, containing in any order the missing sequence values up to the `ack`.  Upon receipt those missed packets should be resent verbatim.

By default a stream should be invalidated if a sequence has been missed three or more times, or there's more than 100 missed packets by default (senders cannot send more than that without a confirming range). When there's consistently missing packets, senders should limit the number of packets beyond the confirmed range. (needs more examples/definition)


<a name="peer" />
### `peer` - Introductions to new hashnames

For any hashname to send an open to another it must first have it's hashname, so there is a two step process starting with a "type":"peer" stream. Since new hashnames are discovered only from another (in the `see` values), they are tracked as a "via" so that they can be sent a peer request when a connection is being made to a hashname they sent.

This also serves as a workaround if any NAT exists, so that the two hashnames can send a packet to each other to make sure the path between them is open, this is called "hole punching." The `peer` value is used to do this and contains the target hashname being contacted for the first time. The recipient of the peer request must then send a connect (below) to the target.

<a name="connect" />
### `connect` - Connect to a hashname

The "type":"connect" is an immediate result of a peer request and must also contain an "ip":"1.2.3.4" and "port":5678 with the values being of the peer requestor and a BODY of their public key.

The recipient can use the given IP, port, and public key to send an open request to the target.  If a NAT existed, the target should have already sent a packet to ensure their side has a path and the open should then make it through.

<a name="seek" />
### `seek` - Finding Hashnames (DHT)

Any network can support a DHT if enough of it's hashnames are connected to each other and respond to `seek` requests properly.  The bulk of the complexity is in the rules around maintaining a mesh of lines and calculating distance (to be defined again here based on v1).

The `seek` value is always a 40 character hex (a SHA1 of anything), it can be used to find other hashnames directly or by an app to find one or more hashnames for any arbitrary content.  Each network and app may use this differently, but the basic rules around discovery are the same.

When one hashname wants to lookup a hash, it finds the closest lines it knows and sends a `seek` containing the hash value to them.  They return a compact `see` array of addresses that are closest to the hash value.  The addresses are a compound comma-delimited string containing the "hash,ip,port" (these are intentionally not JSON as the verbosity is not helpful here), for example "a9993e364706816aba3e25717850c26c9cd0d89d,123.45.67.89,10111" and the IP can be v4 or v6 (there can be multiple entries in the array for one hashname). 

<a name="sock" />
### `sock` - Socket Proxy

A stream can be requested to become a simple raw TCP socket proxy by sending a `sock` key with a value of any "IP:PORT", the receiving hashname should carefully decide if it wants to support this and the destination IP to prevent accidental abuse.  If the socket couldn't open or is closed at any point by either side an `end` of true is sent and any informative `err` string value can be included.

As soon as a `sock` is sent it is considered open by the sender until it receives an `end` telling it otherwise, the stream will inherently only send so much data without any confirmation from the recipient that it's open/reading.


<a name="links" />
### Links

One of the principles of telehash is to operate as distributed and decentralized as possible, and a core part of enabling that is having default methods for allowing apps to perform actions independently without requiring an online centralized resource to verify their permissions to do so.  For example, an app should be able to assert a user's identity to another app such that the receiving app can verify the user from the request alone and not be required to ask a central authority.

A link is the name for a special portable packet that any hashname can use and share within a network.  It is identified by the SHA1(signature) of the full packet, and that hash value is used as the id for the link that is referenced in many other places.

Links act as a temporary binding (they all are required to have an `x` expiration and can be short or long-lived) from one hashname to another of some level of trust around a shared resource or identity.  All links also require a `type` field with a value of one of the following (custom app-defined ones use the "_name" pattern):

* network - the `to` is trusted to be part of this network by the `from`
* app - the `to` is running software written by the `from`
* user - the `to` is acting on behalf of a user of this network as identified within this link
* friend - the `to` has verified they are acting on behalf of a friend that is trusted by a user

(TODO: broken-out examples of how to create and use these links, and how they are chained together)

### App-Specific Usage

Apps are encouraged experiment/adapt and use their own custom JSON and BODY values outside of this definition but must prefix all custom JSON fields with an underscore ({"_foo":"bar"}) so as to not cause future conflicts.  All switches should process all of the defined values and if any packet has additional data that it hasn't processed it should give any app the opportunity to handle that data with whatever context the switch has about the packet/sender already (was it signed, in a line, stream, etc) to make it easy to grow and customize the protocol.
